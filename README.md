# craft_the_code

Observer观察者模式
================
主题对象，观察对象，观察者可以订阅/取消对主题对象的关注，主题对象一旦有变化会将变化通知给所有关注自己的观察者。
一对多关系，  

一个主题应该有注册监听、取消监听、通知更新这些方法，最基本的  
观察者应该有一个更新方法，好让主题数据变化时，能够调用该方法通知到所有观察者。  

### JAVA内置观察者
通过抽象类Observable和接口Observer实现  
但是JAVA中只能继承一个类，所以当你实现Observable一个类无法满足需求时，就需要自己实现观察者，定义主题和观察者接口的方式来实现

### 使用场景
发布-订阅




Decorator装饰器模式
================
对一些类功能想扩展，但是又不能修改原有类，这时候就通过装饰器模式实现
一个接口Component
一个具体实现类AComponent
一个装饰器抽象类实现Component，ADecorator，拥有Component同样的方法签名,内部维护了一个Component的实例
一个具体装饰器继承ADecorator，AbDecorator  
参照代码实例，快递装饰器  
其实java里就有这种模式应用  
InputStream就是一个抽象组件  
FileInputStream就是一个具体组件，可以被装饰者包装起来 
FilterInputStream就是一个抽象装饰者 
BufferedInputStream就是具体装饰者



工厂模式
=======
面向接口编程，不是面向实现编程，如何减少对new关键字的依赖，增强程序的弹性，做到代码“对扩展开放，对修改关闭”  

将产品的实现从使用中解耦，产品的实例化创建交给工厂，由具体子类决定到底创建哪一个产品对象  

### 简单工厂模式
即通过独立的工厂类来实现对象的创建实例化
### 工厂模式
将对象的创建交给了具体实现类，底层接口中定义对象的创建方法，所有子类具体实现该对象如何实例化，让类把实例化推迟到子类

### 依赖倒置原则
依赖抽象，不要依赖具体
车类先不要管具体车型，不要从顶端开始，从车子开始，宝马，尼桑都是车子，所以应该有一个接口车，有了一个车子接口，就可以开始设计车长了，而不用理会具体的车子类了  
以上内容还是不容易理解  
### 如何避免违反依赖倒置原则
*变量不可以持有具体类的引用（如果使用new，就会持有具体类的引用，可以使用工厂来避免）  
*不要让类派生自具体类（派生自抽象类或接口）  
*不要覆盖基类中已实现的方法  

### 抽象工厂
车厂有了，可是车子的零部件供应商全国各不相同，需要零部件工厂  
车厂在生产车子时，不在依赖具体的车厂来实现了，而是依赖具体的零部件工厂，通过不同零部件的工厂自由组织成一个虚拟工厂来生产车子，这就是抽象工厂模式  

抽象工厂提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

单例模式
=======
见代码部分，直接使用双重加锁的方式来实现单例，高效

命令模式
=======
把方法调用封装起来   
高内聚，低耦合  
命令请求者和命令实现者之间解耦  
Command 定义统一的命令接口  
ConcreteCommand Command接口的实现者，用来执行具体的命令，某些情况下可以直接充当Receiver  
Receiver 命令执行者  
Invoker  命令请求者，最重要的角色，用来对各个命令进行控制  
任务队列调度就是命令模式，产生任务丢进队列，消费任务执行  

实例代码可以发现有一个缺点，当命令很多时，系统膨胀很快，难以维护。  

适配器模式
=========
客户端通过目标接口调用适配器的方法对适配器发出请求  
适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口  
客户收到调用的结果，但并未察觉这一切是适配器在起转换作用  

###组合
对现有类进行封装，扩展，创建新的类，里面引用旧类，并扩展新的特性，这就是组合  
###继承
extends基类继承父类

###对象适配器
通过组合实现
###类适配器
通过继承实现
###接口适配器
通过抽象类实现，当一个被适配者接口有很多方法，这时通过对象适配器实现接口，则需要重写很多方法，而我们适配的可能只是其中一个两个方法而已，此时将适配器定义成抽象类实现该接口，每个接口实现只有{}，实现类继承抽象类，需要适配哪个接口，具体实现即可，无需全部实现，代码精简  

外观模式
=======
外观模式是提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用  
其实就是对一群方法调用提炼出一个公共方法，入参多点，对上层封装出一个方法供调用  

最少知识原则
==========
只和你的密友谈话，减少对象之间的交互  
不要在一个方法里去调用另一个方法返回的对象的方法  
比如System.out.println();  





















